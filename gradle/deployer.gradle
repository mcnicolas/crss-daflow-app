import groovy.json.*
import groovy.json.JsonBuilder
import groovy.json.JsonSlurper
import groovyx.net.http.RESTClient
import org.gradle.api.GradleException

import static groovyx.net.http.ContentType.JSON


buildscript {
    repositories {
        maven {
            url "https://plugins.gradle.org/m2/"
        }
    }

    dependencies {
        classpath('org.codehaus.groovy.modules.http-builder:http-builder:0.7.2') {
            exclude group: 'org.codehaus.groovy', module: 'groovy-all'
            exclude group: 'org.codehaus.groovy', module: 'groovy'
        }
    }
}

ext {
    //dockerImageVersion = 'git rev-parse --abbrev-ref HEAD'.execute().text.trim()  + "-" + 'git rev-parse --short HEAD'.execute().text.trim()
    // need to uniquely generate version since scdf doesn't force pull image yet.
    dockerImageVersion = project.version + "." + 'git rev-parse --short HEAD'.execute().text.trim();
    appProfile = project.hasProperty('appProfile') ? project.getProperty('appProfile') : 'dev'
    marathonUrl = project.hasProperty('marathonUrl') ? project.getProperty('marathonUrl') : ''
    environmentSet = project.hasProperty('environmentSet') ? project.getProperty('environmentSet') : ''
    marathonCpus = project.hasProperty('marathonCpus') ? project.getProperty('marathonCpus') : 0.25
    marathonMem = project.hasProperty('marathonMem') ? project.getProperty('marathonMem') : 1024

}

def appId = ''

task setupDeployer() {
    doLast {
        println "Setting up deployer: ${project.name}"
        def dockerPath = "registry.marathon.l4lb.thisdcos.directory:5000/${project.name}:$project.dockerImageVersion"

        println dockerPath;

        def deployerFile = "$rootDir/buildtools/deployer/${project.name}.json"

        if (project.hasProperty('v11')) {
            deployerFile = "$rootDir/buildtools/deployer/${project.name}-v11.json"
        }

        new File("$project.buildDir/deployer/").mkdirs()
        new File("$project.buildDir/deployer/${project.name}.json").createNewFile()

        def json = new JsonSlurper().parseText(new File(deployerFile).text)
        json.container.docker.image = dockerPath
        json.env.SPRING_PROFILES_ACTIVE= "${project.appProfile}"
        json.id = "${project.environmentSet}" + json.id;
        json.cpus = "${project.marathonCpus}".toDouble()
        json.mem = "${project.marathonMem}".toDouble()

        appId = "${json.id}"

        def builder = new JsonBuilder(json)
        println builder.toPrettyString()
        new File("$project.buildDir/deployer/${project.name}.json").text = builder.toPrettyString()
    }
}

task stopApp(dependsOn: setupDeployer)  {
    doLast {
        // stop process app
        logger.info "Stopping current deployed app: ${appId}"
        def proc = "curl -X DELETE $project.marathonUrl/${appId}".execute()
        println "curl -X DELETE $project.marathonUrl$appId"
        Thread.start { System.err << proc.err }
        proc.waitFor()
        println "Stopped"
    }
}


task deployApp(dependsOn: setupDeployer) {
    doFirst {
        if (!project.hasProperty('marathonUrl')) {
            throw new GradleException("Property marathonUrl not supplied. Please supply via -PmarathonUrl=http//ip.marathon/v2")
        }
    }
    doLast {

        def definitionFile = "$project.buildDir/deployer/${project.name}.json"
        def marathonDefinition = new groovy.json.JsonSlurper().parse(file(definitionFile))
        def marathonClient = new RESTClient("$marathonUrl/$appId?force=true", JSON)

        if (project.hasProperty('dcosToken')) {
            marathonClient.setHeaders([Authorization: "token=${project.ext.dcosToken}"])
            marathonClient.ignoreSSLIssues()
        }

        def response = marathonClient.put(body: marathonDefinition).getData()

        def metadata = "marathon-deployment-$project.name"
        file(metadata).createNewFile()
        file(metadata).text = response

        logger.info "Deployed using appId=$marathonDefinition.id and marathonDefinition=" + definitionFile
        logger.info "Marathon details = [deploymentId: $response.deploymentId, version: $response.version]"
    }
}


